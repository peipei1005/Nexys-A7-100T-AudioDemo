//--------------------------------------------------------------------------------------------
//
// Generated by X-HDL VHDL Translator - Version 2.0.0 Feb. 1, 2011
// ?? ?? 29 2023 16:07:06
//
//      Input file      : 
//      Component name  : ramcntrl
//      Author          : 
//      Company         : 
//
//      Description     : 
//
//
//--------------------------------------------------------------------------------------------


module RamCntrl(clk_i, rst_i, rnw_i, be_i, addr_i, data_i, cs_i, data_o, rd_ack_o, wr_ack_o, Mem_A, Mem_DQ_O, Mem_DQ_I, Mem_DQ_T, Mem_CEN, Mem_OEN, Mem_WEN, Mem_UB, Mem_LB);
   parameter        C_RW_CYCLE_NS = 100;
   input            clk_i;
   input            rst_i;
   input            rnw_i;
   input [3:0]      be_i;
   input [31:0]     addr_i;
   input [31:0]     data_i;
   input            cs_i;
   output [31:0]    data_o;
   reg [31:0]       data_o;
   output           rd_ack_o;
   reg              rd_ack_o;
   output           wr_ack_o;
   reg              wr_ack_o;
   
   output [26:0]    Mem_A;
   reg [26:0]       Mem_A;
   output [15:0]    Mem_DQ_O;
   reg [15:0]       Mem_DQ_O;
   input [15:0]     Mem_DQ_I;
   output [15:0]    Mem_DQ_T;
   output           Mem_CEN;
   reg              Mem_CEN;
   output           Mem_OEN;
   reg              Mem_OEN;
   output           Mem_WEN;
   reg              Mem_WEN;
   output           Mem_UB;
   reg              Mem_UB;
   output           Mem_LB;
   reg              Mem_LB;
   
   
   parameter [2:0]  States_Idle = 0,
                    States_AssertCen = 1,
                    States_AssertOenWen = 2,
                    States_Waitt = 3,
                    States_Deassert = 4,
                    States_SendData = 5,
                    States_Ack = 6,
                    States_Done = 7;
   
   reg [2:0]        State;
   reg [2:0]        NState;
   
   reg              TwoCycle;
   
   reg              AddrLsb;
   
   reg              RnwInt;
   
   reg [3:0]        BeInt;
   
   reg [31:0]       AddrInt;
   
   reg [31:0]       Data2WrInt;
   
   reg [31:0]       DataRdInt;
   
   reg [7:0]        CntCycleTime;
   
   reg              RstInt;
   
   
   always @(posedge clk_i)
   begin: REGISTER_INT
      
      begin
         if (State == States_Idle)
         begin
            RnwInt <= rnw_i;
            BeInt <= be_i;
            AddrInt <= addr_i;
            Data2WrInt <= data_i;
            RstInt <= rst_i;
         end
      end
   end
   
   
   always @(posedge clk_i)
   begin: FSM_REGISTER_STATES
      
      begin
         if (RstInt == 1'b1)
            State <= States_Idle;
         else
            State <= NState;
      end
   end
   
   
   always @(cs_i or TwoCycle or CntCycleTime or State)
   begin: FSM_TRANSITIONS
      case (State)
         States_Idle :
            if (cs_i == 1'b1)
               NState <= States_AssertCen;
            else
               NState <= States_Idle;
         States_AssertCen :
            NState <= States_AssertOenWen;
         States_AssertOenWen :
            NState <= States_Waitt;
         States_Waitt :
            if (CntCycleTime == ((C_RW_CYCLE_NS/10) - 2))
               NState <= States_Deassert;
            else
               NState <= States_Waitt;
         States_Deassert :
            NState <= States_SendData;
         States_SendData :
            if (TwoCycle == 1'b1)
               NState <= States_AssertCen;
            else
               NState <= States_Ack;
         States_Ack :
            NState <= States_Done;
         States_Done :
            NState <= States_Idle;
         default :
            NState <= States_Idle;
      endcase
   end
   
   
   always @(posedge clk_i)
   begin: CYCLE_COUNTER
      
      begin
         if (State == States_Waitt)
            CntCycleTime <= CntCycleTime + 1;
         else
            CntCycleTime <= 0;
      end
   end
   
   
   always @(posedge clk_i)
   begin: ASSERT_CEN
      
      begin
         if (State == States_AssertOenWen | State == States_Waitt | State == States_Deassert)
            Mem_CEN <= 1'b0;
         else
            Mem_CEN <= 1'b1;
      end
   end
   
   
   always @(posedge clk_i)
   begin: ASSERT_WENOEN
      
      begin
         if (State == States_Waitt | State == States_Deassert)
         begin
            if (RnwInt == 1'b1)
            begin
               Mem_OEN <= 1'b0;
               Mem_WEN <= 1'b1;
            end
            else
            begin
               Mem_OEN <= 1'b1;
               Mem_WEN <= 1'b0;
            end
         end
         else
         begin
            Mem_OEN <= 1'b1;
            Mem_WEN <= 1'b1;
         end
      end
   end
   
   
   always @(posedge clk_i)
   begin: ASSIGN_TWOCYCLE
      
      begin
         if (RstInt == 1'b1)
            TwoCycle <= 1'b0;
         else if (State == States_AssertCen & be_i == 4'b1111)
            TwoCycle <= (~TwoCycle);
      end
   end
   
   
   always @(posedge clk_i)
   begin: ASSIGN_ADDR_LSB
      
      begin
         if (RstInt == 1'b1)
            AddrLsb <= 1'b0;
         else if (State == States_AssertCen)
            case (BeInt)
               4'b1111 :
                  AddrLsb <= (~TwoCycle);
               4'b1100, 4'b0100, 4'b1000 :
                  AddrLsb <= 1'b1;
               4'b0011, 4'b0010, 4'b0001 :
                  AddrLsb <= 1'b0;
               default :
                  ;
            endcase
      end
   end
   
   
   always @(posedge clk_i)
   begin: ASSIGN_ADDRESS
      
      begin
         if (RstInt == 1'b1)
            Mem_A <= {27{1'b0}};
         else if (State == States_AssertOenWen | State == States_Waitt | State == States_Deassert)
            Mem_A <= {AddrInt[26:1], AddrLsb};
      end
   end
   
   
   always @(posedge clk_i)
   begin: ASSIGN_DATA
      
      begin
         if ((State == States_AssertOenWen | State == States_Waitt | State == States_Deassert) & RnwInt == 1'b0)
            case (BeInt)
               4'b1111 :
                  if (TwoCycle == 1'b1)
                     Mem_DQ_O <= Data2WrInt[15:0];
                  else
                     Mem_DQ_O <= Data2WrInt[31:16];
               4'b0011, 4'b0010, 4'b0001 :
                  Mem_DQ_O <= Data2WrInt[15:0];
               4'b1100, 4'b1000, 4'b0100 :
                  Mem_DQ_O <= Data2WrInt[31:16];
               default :
                  ;
            endcase
         else
            Mem_DQ_O <= {16{1'b0}};
      end
   end
   
   assign Mem_DQ_T = (RnwInt == 1'b1) ? {16{1'b1}} : 
                     {16{1'b0}};
   
   
   always @(posedge clk_i)
   begin: READ_DATA
      
      begin
         if (RstInt == 1'b1)
            DataRdInt <= {32{1'b0}};
         else if (State == States_Deassert)
            case (BeInt)
               4'b1111 :
                  if (TwoCycle == 1'b1)
                     DataRdInt[15:0] <= Mem_DQ_I;
                  else
                     DataRdInt[31:16] <= Mem_DQ_I;
               4'b0011, 4'b1100 :
                  begin
                     DataRdInt[15:0] <= Mem_DQ_I;
                     DataRdInt[31:16] <= Mem_DQ_I;
                  end
               4'b0100, 4'b0001 :
                  begin
                     DataRdInt[7:0] <= Mem_DQ_I[7:0];
                     DataRdInt[15:8] <= Mem_DQ_I[7:0];
                     DataRdInt[23:16] <= Mem_DQ_I[7:0];
                     DataRdInt[31:24] <= Mem_DQ_I[7:0];
                  end
               4'b1000, 4'b0010 :
                  begin
                     DataRdInt[7:0] <= Mem_DQ_I[15:8];
                     DataRdInt[15:8] <= Mem_DQ_I[15:8];
                     DataRdInt[23:16] <= Mem_DQ_I[15:8];
                     DataRdInt[31:24] <= Mem_DQ_I[15:8];
                  end
               default :
                  ;
            endcase
      end
   end
   
   
   always @(posedge clk_i)
   begin: REGISTER_DREAD
      
      begin
         if (State == States_Ack)
            data_o <= DataRdInt;
      end
   end
   
   
   always @(posedge clk_i)
   begin: REGISTER_ACK
      
      begin
         if (State == States_Ack & TwoCycle == 1'b0)
         begin
            if (RnwInt == 1'b1)
            begin
               rd_ack_o <= 1'b1;
               wr_ack_o <= 1'b0;
            end
            else
            begin
               rd_ack_o <= 1'b0;
               wr_ack_o <= 1'b1;
            end
         end
         else
         begin
            rd_ack_o <= 1'b0;
            wr_ack_o <= 1'b0;
         end
      end
   end
   
   
   always @(posedge clk_i)
   begin: ASSIGN_UB_LB
      
      begin
         if (RnwInt == 1'b0)
         begin
            if (State == States_AssertOenWen | State == States_Waitt | State == States_Deassert)
               case (BeInt)
                  4'b1000, 4'b0010 :
                     begin
                        Mem_UB <= 1'b0;
                        Mem_LB <= 1'b1;
                     end
                  4'b0100, 4'b0001 :
                     begin
                        Mem_UB <= 1'b1;
                        Mem_LB <= 1'b0;
                     end
                  default :
                     begin
                        Mem_UB <= 1'b0;
                        Mem_LB <= 1'b0;
                     end
               endcase
         end
         else
         begin
            Mem_UB <= 1'b0;
            Mem_LB <= 1'b0;
         end
      end
   end
   
endmodule
